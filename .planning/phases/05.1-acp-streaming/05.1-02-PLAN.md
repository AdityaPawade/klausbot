---
phase: 05.1-acp-streaming
plan: 02
type: execute
wave: 2
depends_on: ["05.1-01"]
files_modified:
  - src/daemon/acp-client.ts
  - src/telegram/streamer.ts
  - src/daemon/gateway.ts
  - src/memory/context.ts
autonomous: true

must_haves:
  truths:
    - "User sends message, response streams to Telegram in chunks"
    - "Typing indicator while streaming, replaced by actual message"
    - "Gateway uses ACP client instead of spawner"
    - "Existing functionality preserved (identity, memory, skills)"
  artifacts:
    - path: "src/daemon/acp-client.ts"
      provides: "ACP client wrapping query() with streaming"
      exports: ["queryWithStreaming"]
    - path: "src/telegram/streamer.ts"
      provides: "Telegram message streaming with debounce"
      exports: ["TelegramStreamer"]
    - path: "src/daemon/gateway.ts"
      provides: "Gateway using ACP client"
      contains: "queryWithStreaming"
  key_links:
    - from: "src/daemon/acp-client.ts"
      to: "src/mcp/index.ts"
      via: "import klausbotMcp"
      pattern: "import.*klausbotMcp"
    - from: "src/daemon/acp-client.ts"
      to: "src/telegram/streamer.ts"
      via: "TelegramStreamer for chunk delivery"
      pattern: "TelegramStreamer"
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/acp-client.ts"
      via: "replaces queryClaudeCode"
      pattern: "queryWithStreaming"
---

<objective>
Replace CLI spawner with ACP client for streaming responses to Telegram.

Purpose: Enable real-time message streaming (not wait-for-completion) and typed MCP tool access.
Output: Gateway uses query() from claude-agent-sdk with streaming to Telegram.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-acp-streaming/05.1-RESEARCH.md
@.planning/phases/05.1-acp-streaming/05.1-01-SUMMARY.md
@src/daemon/spawner.ts
@src/daemon/gateway.ts
@src/memory/context.ts
@src/telegram/bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram streamer with debounce</name>
  <files>
    - src/telegram/streamer.ts
    - src/telegram/index.ts
  </files>
  <action>
1. Create `src/telegram/streamer.ts`:

```typescript
import type { Bot } from 'grammy';
import type { MyContext } from './bot.js';

/**
 * Streams text chunks to Telegram with debounce
 * Sends initial message, then edits with accumulated content
 */
export class TelegramStreamer {
  private buffer = '';
  private messageId: number | null = null;
  private lastEdit = 0;
  private editInterval = 500; // ms between edits (Telegram rate limit safe)
  private flushTimer: NodeJS.Timeout | null = null;

  constructor(
    private chatId: number,
    private bot: Bot<MyContext>
  ) {}

  /**
   * Add text chunk to buffer
   * Flushes automatically on interval
   */
  async addChunk(text: string): Promise<void> {
    this.buffer += text;
    const now = Date.now();

    // Debounce: only edit every 500ms
    if (now - this.lastEdit > this.editInterval) {
      await this.flush();
    } else if (!this.flushTimer) {
      // Schedule flush for later
      this.flushTimer = setTimeout(() => {
        this.flushTimer = null;
        this.flush().catch(() => {});
      }, this.editInterval - (now - this.lastEdit));
    }
  }

  /**
   * Flush buffer to Telegram
   * Creates new message or edits existing
   */
  async flush(): Promise<void> {
    if (!this.buffer) return;
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = null;
    }

    try {
      if (this.messageId) {
        // Edit existing message
        await this.bot.api.editMessageText(
          this.chatId,
          this.messageId,
          this.buffer
        );
      } else {
        // Send new message
        const msg = await this.bot.api.sendMessage(this.chatId, this.buffer);
        this.messageId = msg.message_id;
      }
      this.lastEdit = Date.now();
    } catch (err) {
      // Ignore edit errors (message unchanged, rate limit, etc.)
    }
  }

  /**
   * Get final message content
   */
  getContent(): string {
    return this.buffer;
  }

  /**
   * Get message ID if sent
   */
  getMessageId(): number | null {
    return this.messageId;
  }
}
```

2. Update `src/telegram/index.ts` to export TelegramStreamer
  </action>
  <verify>
    - File exists: `ls src/telegram/streamer.ts`
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>TelegramStreamer class with 500ms debounce, edit-in-place streaming</done>
</task>

<task type="auto">
  <name>Task 2: Create ACP client with streaming</name>
  <files>
    - src/daemon/acp-client.ts
    - src/daemon/index.ts
  </files>
  <action>
1. Create `src/daemon/acp-client.ts`:

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk';
import type { Bot } from 'grammy';
import { klausbotMcp } from '../mcp/index.js';
import { TelegramStreamer } from '../telegram/streamer.js';
import { buildSystemPrompt, KLAUSBOT_HOME } from '../memory/index.js';
import { createChildLogger } from '../utils/logger.js';
import type { MyContext } from '../telegram/bot.js';

const logger = createChildLogger('acp-client');

/** Response from ACP query */
export interface AcpResponse {
  result: string;
  cost_usd: number;
  session_id: string;
  duration_ms: number;
  is_error: boolean;
}

/** Options for ACP query */
export interface AcpOptions {
  /** Additional system prompt instructions */
  additionalInstructions?: string;
  /** Telegram bot for streaming */
  bot?: Bot<MyContext>;
  /** Chat ID for streaming (required if bot provided) */
  chatId?: number;
}

/**
 * Query Claude via Agent SDK with streaming to Telegram
 */
export async function queryWithStreaming(
  prompt: string,
  options: AcpOptions = {}
): Promise<AcpResponse> {
  const startTime = Date.now();
  let streamer: TelegramStreamer | null = null;

  // Set up streamer if bot and chatId provided
  if (options.bot && options.chatId) {
    streamer = new TelegramStreamer(options.chatId, options.bot);
  }

  // Build system prompt
  let systemPrompt = buildSystemPrompt();
  if (options.additionalInstructions) {
    systemPrompt += '\n\n' + options.additionalInstructions;
  }

  logger.info(
    { prompt: prompt.slice(0, 100), cwd: KLAUSBOT_HOME },
    'Starting ACP query'
  );

  let result = '';
  let cost_usd = 0;
  let session_id = '';
  let is_error = false;

  try {
    for await (const message of query({
      prompt,
      options: {
        cwd: KLAUSBOT_HOME,
        mcpServers: { klausbot: klausbotMcp },
        allowedTools: [
          'mcp__klausbot__create_cron',
          'mcp__klausbot__list_crons',
          'mcp__klausbot__delete_cron',
          'Read', 'Write', 'Edit', 'Glob', 'Grep', 'Bash',
        ],
        systemPrompt,
        permissionMode: 'bypassPermissions',
      },
    })) {
      // Check MCP server status on init
      if (message.type === 'system' && message.subtype === 'init') {
        const failed = message.mcp_servers?.filter(
          (s: { status: string }) => s.status !== 'connected'
        );
        if (failed?.length) {
          logger.warn({ failed }, 'MCP servers failed to connect');
        }
      }

      // Stream assistant text chunks
      if (message.type === 'assistant' && message.message?.content) {
        for (const block of message.message.content) {
          if ('text' in block && typeof block.text === 'string') {
            result += block.text;
            if (streamer) {
              await streamer.addChunk(block.text);
            }
          }
        }
      }

      // Capture result metadata
      if (message.type === 'result') {
        cost_usd = message.total_cost_usd ?? 0;
        session_id = message.session_id ?? '';
        is_error = message.is_error ?? false;
        break;
      }
    }

    // Final flush
    if (streamer) {
      await streamer.flush();
    }

  } catch (err) {
    is_error = true;
    result = err instanceof Error ? err.message : String(err);
    logger.error({ err }, 'ACP query failed');
  }

  const duration_ms = Date.now() - startTime;
  logger.info(
    { duration_ms, cost_usd, session_id, is_error },
    'ACP query complete'
  );

  return { result, cost_usd, session_id, duration_ms, is_error };
}
```

2. Update `src/daemon/index.ts` to export queryWithStreaming alongside queryClaudeCode (for backward compatibility during transition)

CRITICAL:
- permissionMode: 'bypassPermissions' for autonomous operation
- Include all standard Claude tools (Read, Write, Edit, Glob, Grep, Bash) plus MCP tools
- Server name in mcpServers must match createSdkMcpServer name ("klausbot")
  </action>
  <verify>
    - File exists: `ls src/daemon/acp-client.ts`
    - TypeScript compiles: `npx tsc --noEmit`
    - Imports resolve: klausbotMcp, TelegramStreamer, buildSystemPrompt
    - Check exports: `grep -E 'export.*(buildSystemPrompt|KLAUSBOT_HOME)' src/memory/index.ts`
  </verify>
  <done>ACP client using query() async generator with streaming to Telegram</done>
</task>

<task type="auto">
  <name>Task 3: Wire ACP client into gateway, update system prompt</name>
  <files>
    - src/daemon/gateway.ts
    - src/memory/context.ts
  </files>
  <action>
1. Update `src/daemon/gateway.ts`:
   - Replace import of queryClaudeCode with queryWithStreaming from './acp-client.js'
   - Import bot at top level (already imported)
   - In processMessage():
     - Remove typing indicator interval (streaming replaces it)
     - Replace queryClaudeCode call with queryWithStreaming:
       ```typescript
       const response = await queryWithStreaming(msg.text, {
         additionalInstructions,
         bot,
         chatId: msg.chatId,
       });
       ```
     - Remove splitAndSend call - streaming already sent the message
     - If is_error, send error message (streamer may not have content)
     - Keep conversation logging, identity cache invalidation, auto-commit

2. Update `src/memory/context.ts`:
   - In getRetrievalInstructions(), REMOVE the entire "Managing Scheduled Tasks" section
   - Cron management now happens via MCP tools, not CLI instructions
   - Claude will discover the cron tools via allowedTools automatically

3. Simplify processMessage flow:
   ```typescript
   async function processMessage(msg: QueuedMessage): Promise<void> {
     try {
       logUserMessage(msg.text);

       const isBootstrap = needsBootstrap();
       const chatIdContext = `<session-context>...`;
       const additionalInstructions = isBootstrap
         ? chatIdContext + '\n\n' + BOOTSTRAP_INSTRUCTIONS
         : chatIdContext;

       const response = await queryWithStreaming(msg.text, {
         additionalInstructions,
         bot,
         chatId: msg.chatId,
       });

       queue.complete(msg.id);

       if (response.is_error) {
         await bot.api.sendMessage(msg.chatId, `Error: ${response.result}`);
       } else {
         logAssistantMessage(response.result);
         invalidateIdentityCache();
         // Message already streamed - no sendMessage needed
       }

       await autoCommitChanges();
     } catch (err) {
       // error handling...
     }
   }
   ```

IMPORTANT:
- Remove typing indicator (streaming provides visual feedback)
- Remove splitAndSend (streaming handles it)
- Keep chatId in session-context (MCP tools still need it)
  </action>
  <verify>
    - Gateway compiles: `npx tsc --noEmit`
    - No CLI cron instructions in context.ts
    - queryWithStreaming imported and used in gateway
  </verify>
  <done>Gateway uses ACP streaming, CLI cron instructions removed from system prompt</done>
</task>

</tasks>

<verification>
1. Full build: `npm run build` succeeds
2. Gateway imports acp-client, not spawner for main queries
3. context.ts has no CLI cron instructions
4. Start gateway briefly to check no import errors: `timeout 5 npm start || true`
</verification>

<success_criteria>
- TelegramStreamer class exports from src/telegram/
- queryWithStreaming exports from src/daemon/
- gateway.ts uses queryWithStreaming instead of queryClaudeCode
- CLI cron instructions removed from memory/context.ts
- npm run build succeeds
- Gateway starts without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-acp-streaming/05.1-02-SUMMARY.md`
</output>
