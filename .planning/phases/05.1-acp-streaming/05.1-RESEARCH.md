# Phase 5.1: ACP Streaming - Research

**Researched:** 2026-01-30
**Domain:** Agent communication protocols, MCP server development, streaming architecture
**Confidence:** HIGH

## Summary

Phase 5.1 replaces the current CLI-spawner architecture with a proper agent-client model using the Claude Agent SDK and MCP. The current implementation spawns `claude` CLI via `child_process`, waits for completion, then sends the entire response. The new architecture uses `@anthropic-ai/claude-agent-sdk` for streaming responses and `@modelcontextprotocol/sdk` to expose cron operations as typed MCP tools.

The Claude Agent SDK provides the `query()` function that returns an async generator of messages, enabling real-time streaming. MCP servers can run in-process via `createSdkMcpServer()`, eliminating the need for separate processes. This architecture is vendor-agnostic: the gateway acts as an ACP client consuming Claude Code as an agent.

**Primary recommendation:** Use `@anthropic-ai/claude-agent-sdk` with `createSdkMcpServer()` for in-process MCP tools. Stream `assistant` messages to Telegram as they arrive.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @anthropic-ai/claude-agent-sdk | latest | Agent SDK for streaming Claude interactions | Official Anthropic SDK, handles agent loop |
| @modelcontextprotocol/sdk | 1.25.x | MCP server/client SDK | Official MCP implementation, v2 in Q1 2026 |
| zod | 3.x | Schema validation for MCP tools | Required peer dependency for MCP SDK |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @modelcontextprotocol/server | 1.25.x | Server-side MCP helpers | When building standalone MCP servers |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| claude-agent-sdk | @zed-industries/claude-code-acp | claude-code-acp is adapter for external clients, SDK is official |
| In-process MCP | Stdio MCP server | Stdio requires separate process, adds complexity |

**Installation:**
```bash
npm install @anthropic-ai/claude-agent-sdk @modelcontextprotocol/sdk zod@3
```

## Architecture Patterns

### Recommended Project Structure
```
src/
  mcp/
    server.ts        # createSdkMcpServer() with cron tools
    tools/
      cron.ts        # create_cron, list_crons, delete_cron tools
  daemon/
    acp-client.ts    # query() wrapper with streaming
    gateway.ts       # Updated to use ACP client
```

### Pattern 1: In-Process MCP Server
**What:** Define MCP tools that run in the same Node.js process as the gateway
**When to use:** When tools need access to local state (cron store, memory)
**Example:**
```typescript
// Source: https://platform.claude.com/docs/en/agent-sdk/mcp
import { createSdkMcpServer, tool } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";

const mcpServer = createSdkMcpServer({
  name: "klausbot-mcp",
  version: "1.0.0",
  tools: [
    tool(
      "create_cron",
      "Create a scheduled task",
      {
        name: z.string().describe("Human-readable job name"),
        schedule: z.string().describe("Schedule (cron expr or natural language)"),
        instruction: z.string().describe("What Claude should do"),
        chatId: z.number().describe("Telegram chat ID for notifications"),
      },
      async (args) => {
        // Call existing cron service
        const job = createCronJob(args);
        return { content: [{ type: "text", text: JSON.stringify(job) }] };
      }
    ),
  ],
});
```

### Pattern 2: Streaming Message Handler
**What:** Process messages from query() async generator, stream to Telegram
**When to use:** For real-time response streaming
**Example:**
```typescript
// Source: https://platform.claude.com/docs/en/agent-sdk/typescript
import { query } from "@anthropic-ai/claude-agent-sdk";

for await (const message of query({
  prompt: userMessage,
  options: {
    mcpServers: { "klausbot": mcpServer },
    allowedTools: ["mcp__klausbot__*"],
    systemPrompt: buildSystemPrompt(),
  }
})) {
  if (message.type === "assistant" && message.message?.content) {
    for (const block of message.message.content) {
      if ("text" in block) {
        // Stream text chunk to Telegram
        await streamToTelegram(chatId, block.text);
      }
    }
  } else if (message.type === "result") {
    // Query complete
    break;
  }
}
```

### Pattern 3: Tool Permission via allowedTools
**What:** Whitelist MCP tools explicitly
**When to use:** Always, for security
**Example:**
```typescript
options: {
  mcpServers: { "klausbot": mcpServer },
  allowedTools: [
    "mcp__klausbot__create_cron",
    "mcp__klausbot__list_crons",
    "mcp__klausbot__delete_cron",
    "Read", "Write", "Edit", "Glob", "Grep", "Bash"  // Keep existing tools
  ],
}
```

### Anti-Patterns to Avoid
- **Spawning CLI for each request:** Defeats purpose of streaming, high latency
- **Using stdio MCP transport:** Requires separate process management
- **console.log in MCP servers:** Corrupts JSON-RPC over stdio (not applicable for in-process)
- **Blocking on full response:** Must stream chunks incrementally

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Agent loop | Custom while loop | `query()` async generator | SDK handles retries, context, tool execution |
| MCP tool schema | Manual JSON schema | Zod + `tool()` helper | Type-safe, auto-generates schema |
| Streaming | Buffer then send | Process message.content blocks | SDK yields as messages arrive |
| Permission checking | Custom canUseTool | allowedTools array | SDK enforces permissions |

**Key insight:** The Claude Agent SDK abstracts the agent loop (tool execution, context management, retries) entirely. Don't rebuild it.

## Common Pitfalls

### Pitfall 1: Not Handling Partial Messages
**What goes wrong:** Missing `includePartialMessages: true` means no streaming granularity
**Why it happens:** Default is false, seems like streaming works without it
**How to avoid:** For fine-grained streaming, set `includePartialMessages: true` and handle `stream_event` type
**Warning signs:** Entire response arrives at once despite async iterator

### Pitfall 2: MCP Tool Naming Convention
**What goes wrong:** Tools not found because name doesn't follow pattern
**Why it happens:** MCP tools are prefixed `mcp__<server-name>__<tool-name>`
**How to avoid:** Use `allowedTools: ["mcp__klausbot__*"]` pattern
**Warning signs:** "Tool not found" errors, Claude sees tools but can't call them

### Pitfall 3: Session Not Persisting
**What goes wrong:** Each query starts fresh, loses conversation context
**Why it happens:** Not passing `resume` option with session ID
**How to avoid:** Capture `session_id` from init message, pass `resume: sessionId` for continuation
**Warning signs:** Claude asks for context it already had

### Pitfall 4: Blocking on Telegram Edits
**What goes wrong:** Rate limiting from too many message edits
**Why it happens:** Editing message for each token
**How to avoid:** Batch chunks, edit on sentence boundaries or time intervals (e.g., every 500ms)
**Warning signs:** 429 errors from Telegram API

### Pitfall 5: MCP Server Connection Failure
**What goes wrong:** Silent failures when MCP server doesn't connect
**Why it happens:** Not checking `system.init` message for server status
**How to avoid:** Check `message.mcp_servers` status in init message
**Warning signs:** Tools exist but never called, no errors logged

## Code Examples

Verified patterns from official sources:

### Complete Query with MCP Server
```typescript
// Source: https://platform.claude.com/docs/en/agent-sdk/mcp
import { query, createSdkMcpServer, tool } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";
import { createCronJob, listCronJobs, deleteCronJob } from "./cron/service.js";

// Define in-process MCP server
const klausbotMcp = createSdkMcpServer({
  name: "klausbot",
  version: "1.0.0",
  tools: [
    tool(
      "create_cron",
      "Create a scheduled task that runs at specified times",
      {
        name: z.string().describe("Human-readable job name"),
        schedule: z.string().describe("Schedule: cron expression or natural language"),
        instruction: z.string().describe("What to do when job runs"),
        chatId: z.number().describe("Telegram chat ID for notifications"),
      },
      async ({ name, schedule, instruction, chatId }) => {
        const job = createCronJob({ name, schedule, instruction, chatId });
        return {
          content: [{
            type: "text",
            text: `Created cron job "${job.name}" (${job.id}). Next run: ${new Date(job.nextRunAtMs).toISOString()}`
          }]
        };
      }
    ),
    tool(
      "list_crons",
      "List all scheduled tasks for a chat",
      { chatId: z.number().describe("Telegram chat ID") },
      async ({ chatId }) => {
        const jobs = listCronJobs(chatId);
        return {
          content: [{
            type: "text",
            text: jobs.length ? JSON.stringify(jobs, null, 2) : "No scheduled tasks found."
          }]
        };
      }
    ),
    tool(
      "delete_cron",
      "Delete a scheduled task",
      { id: z.string().describe("Job ID (UUID)") },
      async ({ id }) => {
        const deleted = deleteCronJob(id);
        return {
          content: [{
            type: "text",
            text: deleted ? `Deleted job ${id}` : `Job ${id} not found`
          }]
        };
      }
    ),
  ],
});

// Query with streaming
async function queryWithStreaming(prompt: string, chatId: number) {
  const chunks: string[] = [];

  for await (const message of query({
    prompt,
    options: {
      mcpServers: { "klausbot": klausbotMcp },
      allowedTools: ["mcp__klausbot__*", "Read", "Write", "Edit", "Glob", "Grep"],
      systemPrompt: buildSystemPrompt(),
      cwd: KLAUSBOT_HOME,
    }
  })) {
    if (message.type === "system" && message.subtype === "init") {
      // Check MCP server status
      const failed = message.mcp_servers.filter(s => s.status !== "connected");
      if (failed.length > 0) console.error("MCP failures:", failed);
    }

    if (message.type === "assistant" && message.message?.content) {
      for (const block of message.message.content) {
        if ("text" in block) {
          chunks.push(block.text);
          // Stream to Telegram (debounced)
        }
      }
    }

    if (message.type === "result") {
      return {
        result: chunks.join(""),
        cost_usd: message.total_cost_usd,
        session_id: message.session_id,
        is_error: message.is_error,
      };
    }
  }
}
```

### Telegram Streaming with Debounce
```typescript
// Source: Klausbot existing pattern + Telegram API best practices
class TelegramStreamer {
  private buffer = "";
  private messageId: number | null = null;
  private lastEdit = 0;
  private editInterval = 500; // ms between edits

  constructor(private chatId: number, private bot: Bot) {}

  async addChunk(text: string) {
    this.buffer += text;
    const now = Date.now();

    // Debounce: only edit every 500ms
    if (now - this.lastEdit > this.editInterval) {
      await this.flush();
    }
  }

  async flush() {
    if (!this.buffer) return;

    if (this.messageId) {
      // Edit existing message
      await this.bot.api.editMessageText(this.chatId, this.messageId, this.buffer);
    } else {
      // Send new message
      const msg = await this.bot.api.sendMessage(this.chatId, this.buffer);
      this.messageId = msg.message_id;
    }
    this.lastEdit = Date.now();
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| CLI spawn (child_process) | Claude Agent SDK query() | 2025-2026 | Direct streaming, no process overhead |
| CLI string args for tools | MCP typed tools | 2025-2026 | Type-safe, schema-validated tool calls |
| Wait for completion | Async generator streaming | 2025-2026 | Real-time response delivery |
| Manual agent loop | SDK-managed loop | 2025-2026 | Automatic retries, context management |

**Deprecated/outdated:**
- @anthropic-ai/claude-code: Renamed to claude-agent-sdk
- Stdio-only MCP: In-process `createSdkMcpServer()` preferred for same-process tools

## Open Questions

Things that couldn't be fully resolved:

1. **Telegram edit rate limits**
   - What we know: Telegram limits message edits, exact limits undocumented
   - What's unclear: Optimal debounce interval for streaming
   - Recommendation: Start with 500ms, adjust based on 429 errors

2. **Session persistence across restarts**
   - What we know: SDK supports `resume: sessionId`
   - What's unclear: Session data location, persistence requirements
   - Recommendation: Store session_id in conversation log, pass on continuation

3. **Permission mode for cron execution**
   - What we know: `bypassPermissions` skips all prompts
   - What's unclear: Whether cron jobs should use different mode than interactive
   - Recommendation: Use `bypassPermissions` for cron (autonomous), `acceptEdits` for interactive

## Sources

### Primary (HIGH confidence)
- [Claude Agent SDK TypeScript Reference](https://platform.claude.com/docs/en/agent-sdk/typescript) - Complete API reference
- [Claude Agent SDK MCP Integration](https://platform.claude.com/docs/en/agent-sdk/mcp) - createSdkMcpServer, tool permissions
- [Claude Agent SDK Quickstart](https://platform.claude.com/docs/en/agent-sdk/quickstart) - Installation, basic patterns

### Secondary (MEDIUM confidence)
- [MCP TypeScript SDK GitHub](https://github.com/modelcontextprotocol/typescript-sdk) - v1.25.x current, v2 Q1 2026
- [MCP Build Server Tutorial](https://modelcontextprotocol.io/docs/develop/build-server) - TypeScript server patterns

### Tertiary (LOW confidence)
- [@zed-industries/claude-code-acp](https://github.com/zed-industries/claude-code-acp) - ACP adapter reference
- [Agent Client Protocol Spec](https://agentclientprotocol.com/) - Protocol overview

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official Anthropic SDK documentation
- Architecture: HIGH - Patterns from official docs and examples
- Pitfalls: MEDIUM - Some derived from MCP general patterns

**Research date:** 2026-01-30
**Valid until:** 2026-02-28 (MCP v2 may change patterns)
