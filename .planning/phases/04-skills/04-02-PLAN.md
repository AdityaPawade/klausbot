---
phase: 04-skills
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/telegram/commands.ts
  - src/daemon/gateway.ts
  - src/memory/context.ts
autonomous: true

must_haves:
  truths:
    - "User can invoke /skill <name> and get skill executed"
    - "User can invoke /<skillname> directly (e.g., /summarize)"
    - "Skills appear in Telegram's / command menu"
    - "Claude sees available skills in system prompt"
  artifacts:
    - path: "src/telegram/commands.ts"
      provides: "Skill command handlers and registration"
      exports: ["registerSkillCommands", "handleSkillCommand"]
    - path: "src/daemon/gateway.ts"
      provides: "Gateway skill integration"
      contains: "discoverSkills"
  key_links:
    - from: "src/daemon/gateway.ts"
      to: "src/skills/loader.ts"
      via: "discoverSkills import"
      pattern: "import.*discoverSkills"
    - from: "src/telegram/commands.ts"
      to: "bot.api.setMyCommands"
      via: "Telegram API"
      pattern: "setMyCommands"
---

<objective>
Integrate skills with Telegram bot - register skill commands dynamically, handle /skill and direct /<skillname> invocations, and inject skill descriptions into Claude's system prompt.

Purpose: Users can discover and invoke skills through Telegram's command interface.
Output: Working skill invocation via Telegram commands with menu integration.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-skills/04-RESEARCH.md
@.planning/phases/04-skills/04-01-SUMMARY.md
@src/telegram/commands.ts
@src/daemon/gateway.ts
@src/memory/context.ts
@src/daemon/spawner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill command handlers to commands.ts</name>
  <files>src/telegram/commands.ts</files>
  <action>
Add to src/telegram/commands.ts:

1. **normalizeCommandName(skillName: string) function:**
   - Convert hyphens to underscores (Telegram requirement)
   - Lowercase the name
   - Truncate to 32 chars
   ```typescript
   function normalizeCommandName(skillName: string): string {
     return skillName.toLowerCase().replace(/-/g, '_').slice(0, 32);
   }
   ```

2. **registerSkillCommands(bot: Bot, skills: SkillMeta[]) async function:**
   - Build BotCommand array starting with built-in commands:
     ```typescript
     const commands: BotCommand[] = [
       { command: 'start', description: 'Start or check pairing' },
       { command: 'help', description: 'Show available commands' },
       { command: 'status', description: 'Show queue status' },
       { command: 'skill', description: 'Run a skill: /skill <name> [args]' },
       { command: 'skills', description: 'List installed skills' },
     ];
     ```
   - For each user-invocable skill, add normalized command
   - Call `bot.api.setMyCommands(commands.slice(0, 100))` (Telegram limit: 100)
   - Log registration success

3. **handleSkillCommand factory:**
   - Export a factory that takes skills array and returns handler
   - Parse `/skill name args...` format
   - Find matching skill by name or normalized name
   - If found, return `{ skillName, args, skillContent }` for gateway to process
   - If not found, reply with error + list available skills

4. **handleDirectSkillCommand factory:**
   - Similar to above but for `/<skillname> args` format
   - Used when user types skill name directly

Import SkillMeta type from '../skills/index.js'.
  </action>
  <verify>`npx tsc --noEmit` passes; functions exported correctly</verify>
  <done>registerSkillCommands and skill handlers exported from commands.ts</done>
</task>

<task type="auto">
  <name>Task 2: Integrate skills into gateway startup</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Modify src/daemon/gateway.ts:

1. **Import skills:**
   ```typescript
   import { discoverSkills, loadSkillContent, buildSkillsContext, type SkillMeta } from '../skills/index.js';
   import { registerSkillCommands } from '../telegram/commands.js';
   ```

2. **Add module-level skills cache:**
   ```typescript
   let cachedSkills: SkillMeta[] = [];
   ```

3. **In startGateway(), after initializeHome:**
   - Call `cachedSkills = discoverSkills();`
   - Log discovered skills count
   - Call `await registerSkillCommands(bot, cachedSkills);`

4. **Add /skill command handler in gateway:**
   - Handle `/skill <name> [args]` command
   - Find skill in cachedSkills
   - If missing args required, prompt user
   - Load skill content with `loadSkillContent(skill)`
   - Call `queryClaudeCode(userText, { additionalInstructions: skillContent })`
   - Send response to user

   **Note:** spawner.ts ALREADY supports `additionalInstructions` in SpawnerOptions interface (lines 27, 66-68). No spawner changes needed.

5. **Add /skills list command:**
   - List all installed skills with descriptions
   - Format: `*Installed Skills*\n- skill-name: description`

6. **Handle direct skill commands (/<skillname>):**
   - Register handlers for each user-invocable skill
   - Route to same skill execution logic

**Complexity note:** This plan has 3 tasks touching Telegram/gateway/context, but they are tightly coupled (all need skill discovery) and bounded. Splitting would create artificial boundaries since commands.ts registration depends on gateway having skills, and context.ts needs skills for system prompt. Single plan maintains coherence.
  </action>
  <verify>`npx tsc --noEmit`; gateway starts without errors</verify>
  <done>Skills discovered at startup, commands registered, /skill handler working</done>
</task>

<task type="auto">
  <name>Task 3: Add skills context to system prompt</name>
  <files>src/memory/context.ts</files>
  <action>
Modify src/memory/context.ts:

1. **Import buildSkillsContext:**
   ```typescript
   import { discoverSkills, buildSkillsContext } from '../skills/index.js';
   ```

2. **Add skills cache at module level:**
   ```typescript
   let skillsContextCache: string | null = null;
   ```

3. **Create getSkillsContext() function:**
   ```typescript
   export function getSkillsContext(): string {
     if (skillsContextCache !== null) {
       return skillsContextCache;
     }
     const skills = discoverSkills();
     skillsContextCache = buildSkillsContext(skills);
     return skillsContextCache;
   }
   ```

4. **Add invalidateSkillsCache():**
   ```typescript
   export function invalidateSkillsCache(): void {
     skillsContextCache = null;
   }
   ```

5. **Modify buildSystemPrompt():**
   - Add skills context after retrieval instructions
   ```typescript
   export function buildSystemPrompt(): string {
     const identity = loadIdentity();
     const instructions = getRetrievalInstructions();
     const skills = getSkillsContext();
     return identity + '\n\n' + instructions + '\n\n' + skills;
   }
   ```

This allows Claude to auto-select skills based on user intent.
  </action>
  <verify>`npx tsc --noEmit` passes; buildSystemPrompt includes skills context</verify>
  <done>Skills context injected into every Claude session's system prompt</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. Build and run: `npm run build && npm run gateway` starts without errors
3. Telegram `/` menu shows skill command after bot starts
4. `/skills` command lists any installed skills (empty list OK if none installed)
5. **Auto-selection visibility check:** After build, send a message like "what skills are available?" or "list your skills" - Claude should respond with the list from system prompt. This verifies skills are visible to Claude before E2E testing.
</verification>

<success_criteria>
- Skills discovered at gateway startup
- Telegram commands registered via setMyCommands API
- /skill and /skills commands functional
- Skills context appears in Claude's system prompt
- Direct /<skillname> invocation works for installed skills
</success_criteria>

<output>
After completion, create `.planning/phases/04-skills/04-02-SUMMARY.md`
</output>
