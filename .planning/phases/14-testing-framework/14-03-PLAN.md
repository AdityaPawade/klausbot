---
phase: 14-testing-framework
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - tests/unit/daemon/queue.test.ts
  - tests/unit/memory/conversations.test.ts
  - tests/unit/memory/context.test.ts
autonomous: true

must_haves:
  truths:
    - "MessageQueue adds, takes, completes, fails messages with correct status transitions"
    - "MessageQueue persists to disk and recovers processing messages on restart"
    - "parseTranscript handles valid JSONL, malformed lines, and empty input"
    - "extractConversationText combines user/assistant entries from both string and array content formats"
    - "Thread detection identifies active conversation chains within 30-minute gaps"
    - "buildConversationContext produces tiered XML output with correct thread-status tags"
  artifacts:
    - path: "tests/unit/daemon/queue.test.ts"
      provides: "MessageQueue unit tests"
      min_lines: 60
    - path: "tests/unit/memory/conversations.test.ts"
      provides: "parseTranscript + extractConversationText unit tests"
      min_lines: 40
    - path: "tests/unit/memory/context.test.ts"
      provides: "Thread detection + buildConversationContext tests"
      min_lines: 80
  key_links:
    - from: "tests/unit/daemon/queue.test.ts"
      to: "src/daemon/queue.ts"
      via: "import MessageQueue"
      pattern: "import.*MessageQueue"
    - from: "tests/unit/memory/context.test.ts"
      to: "src/memory/context.ts"
      via: "import buildConversationContext"
      pattern: "import.*buildConversationContext"
    - from: "tests/unit/memory/conversations.test.ts"
      to: "src/memory/conversations.ts"
      via: "import parseTranscript, extractConversationText"
      pattern: "import.*(parseTranscript|extractConversationText)"
---

<objective>
Unit tests for stateful P0/P1 modules: MessageQueue (filesystem), transcript parsing (pure logic), and conversation context building (DB + thread detection).

Purpose: These modules handle persistence and conversation intelligence — the core of klausbot's memory system. Testing them with mocked I/O ensures correctness without external dependencies.
Output: 3 test files covering queue lifecycle, transcript parsing, and conversation context with thread detection.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-testing-framework/14-RESEARCH.md
@src/daemon/queue.ts
@src/memory/conversations.ts
@src/memory/context.ts
@src/memory/schema.ts
@src/memory/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MessageQueue unit tests with temp directory</name>
  <files>tests/unit/daemon/queue.test.ts</files>
  <action>
Create `tests/unit/daemon/queue.test.ts` testing MessageQueue from `../../../src/daemon/queue.js`.

**Mocking:** Must mock the logger before importing MessageQueue. Use vi.mock:
```typescript
vi.mock("../../../src/utils/logger.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));
```

**Setup/teardown:** Use `mkdtempSync` + `rmSync` for isolated temp directories per test suite.

**Test cases:**

**add and take:**
- add(12345, "hello") returns a UUID string
- take() returns the added message with status "processing"
- take() on empty queue returns undefined
- Multiple adds, take returns FIFO order

**complete and fail:**
- complete(id) sets status to "done"
- fail(id, "error msg") sets status to "failed" and records error
- complete/fail with unknown id does not throw (logs warning)

**getStats:**
- Empty queue: pending 0, processing 0, failed 0
- After add: pending 1
- After add + take: processing 1
- After add + take + complete: all 0 (done messages counted separately)
- After add + take + fail: failed 1

**getPending:**
- Returns copies of pending messages (not references)
- Excludes processing/done/failed messages

**Persistence and crash recovery:**
- Create queue, add message, create NEW queue from same directory -> message is loaded
- Add message, take (status=processing), create NEW queue -> message recovered to "pending"
- Old done messages (timestamp > 1hr ago) filtered out on load

**Threading context:**
- add() with threading parameter preserves messageThreadId and replyToMessageId
- take() returns message with threading context intact

**Media attachments:**
- add() with media array preserves attachments
- take() returns message with media intact
  </action>
  <verify>`npx vitest run tests/unit/daemon/queue.test.ts --reporter=verbose` — all tests pass, temp dirs cleaned up</verify>
  <done>MessageQueue fully tested: add/take/complete/fail lifecycle, stats tracking, disk persistence, crash recovery, threading context, and media attachments.</done>
</task>

<task type="auto">
  <name>Task 2: Conversation parsing and context building tests</name>
  <files>tests/unit/memory/conversations.test.ts, tests/unit/memory/context.test.ts</files>
  <action>
1. Create `tests/unit/memory/conversations.test.ts` testing pure functions from `../../../src/memory/conversations.js`:

   **parseTranscript:**
   - Valid JSONL (2 lines) -> returns 2 entries with correct types
   - Malformed line mixed with valid -> skips malformed, returns valid entries
   - Empty string -> returns []
   - Single line -> returns 1 entry

   **extractConversationText:**
   - User and assistant entries with array content -> "User: ...\n\nAssistant: ..."
   - Entry with string content (not array) -> handles correctly
   - Entry with no text content -> skipped
   - Mixed entry types (summary, system) -> only user/assistant included
   - Empty entries array -> returns ""

   These functions are pure — no mocking needed. Import directly.

2. Create `tests/unit/memory/context.test.ts` testing context building functions from `../../../src/memory/context.js`:

   **Mocking strategy:** The context module imports `getConversationsForContext` from conversations.ts (which calls getDrizzle), `getHomePath` from home.ts, and `existsSync`/`readFileSync` from fs. We need to mock:
   - `../../../src/memory/conversations.js` to control getConversationsForContext return values
   - `../../../src/memory/home.js` to return temp paths for getHomePath
   - `fs` module: mock `existsSync` and `readFileSync` for identity file tests

   Use `vi.mock` for module-level mocking. Use `vi.hoisted` for values needed in mock factories.

   **Test the exported functions that don't need DB:**

   **getRetrievalInstructions:**
   - Returns string containing "memory-instructions" XML tag
   - Contains "search_memories" tool mention
   - Contains "MANDATORY" enforcement text

   **getSkillReminder / getAgentReminder / getToolGuidance:**
   - Each returns string wrapped in correct XML tags

   **getOrchestrationInstructions:**
   - Contains "start_background_task" mention
   - Contains "60 SECONDS" kill warning

   **getMemoryFirstBookend / getMemoryFirstReminder:**
   - Return strings with correct XML tag names

   **buildConversationContext (mocked conversations):**
   Set up `vi.mocked(getConversationsForContext)` to return controlled data.

   Create fixture conversations using `createConversationRecord` from helpers, with specific timestamps to test tiering:

   - **No conversations:** Returns ""
   - **Active thread (within 30min):** Returns XML with `<thread-status>CONTINUATION`
   - **New conversation (>30min gap):** Returns XML with `<thread-status>NEW CONVERSATION`
   - **Tiered output:** Create convs at: 5min ago (thread), 2hr ago (today), 30hr ago (yesterday), 4 days ago (older). Verify:
     - Thread conv has full `<conversation>` with transcript entries
     - Today conv has full transcript
     - Yesterday conv has `summary="true"` attribute
     - Older conv has `summary="true"` attribute
   - **Budget enforcement:** Create a conversation with very long transcript (>120K chars). Verify output is truncated and contains "[...truncated...]"

   **loadIdentity / reloadIdentity / invalidateIdentityCache:**
   - Mock fs.existsSync to return true for identity files
   - Mock fs.readFileSync to return test content
   - Mock getHomePath to return deterministic paths
   - loadIdentity returns XML-wrapped content
   - invalidateIdentityCache + loadIdentity reloads (returns new content if readFileSync mock changed)
   - reloadIdentity forces fresh read

   **buildSystemPrompt:**
   - When BOOTSTRAP.md exists -> returns its content only
   - When no BOOTSTRAP.md + identity files exist -> returns combined prompt with all sections

   Note: Use `vi.resetModules()` in beforeEach if testing identity cache behavior, since it uses module-level state.
  </action>
  <verify>`npx vitest run tests/unit/memory/ --reporter=verbose` — all tests pass</verify>
  <done>Conversation parsing tested with pure functions. Context building tested with mocked DB layer, covering thread detection (continuation vs new), tiered formatting (full vs summary), budget enforcement, identity loading, and system prompt composition.</done>
</task>

</tasks>

<verification>
- `npm test` passes all tests (plans 02 and 03 combined)
- `npm run test:coverage` shows meaningful coverage on daemon/queue.ts, memory/conversations.ts, memory/context.ts
- No real database, filesystem (outside temp), or network calls in any test
</verification>

<success_criteria>
1. MessageQueue: full lifecycle (add/take/complete/fail), persistence, crash recovery tested
2. parseTranscript + extractConversationText: pure function tests with edge cases
3. buildConversationContext: thread detection, tiered formatting, budget enforcement tested
4. Identity loading and system prompt composition tested
5. All tests pass on `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/14-testing-framework/14-03-SUMMARY.md`
</output>
