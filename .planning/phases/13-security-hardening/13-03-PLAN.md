---
phase: 13-security-hardening
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/daemon/gateway.ts
  - src/security/index.ts
autonomous: true

must_haves:
  truths:
    - "All user prompts are validated before queuing"
    - "Invalid/malicious input receives user-friendly rejection message"
    - "Voice transcripts are also validated (not just text messages)"
    - "Validation errors do NOT reveal detection logic"
  artifacts:
    - path: "src/daemon/gateway.ts"
      provides: "Message handlers with validation integration"
      contains: "validateAndSanitize"
  key_links:
    - from: "src/daemon/gateway.ts"
      to: "src/security/index.ts"
      via: "import validateAndSanitize"
      pattern: "from.*security"
---

<objective>
Integrate input validation into the gateway message flow to sanitize all user input before Claude processing.

Purpose: Close the security loop by applying validation at the gateway entry point, ensuring no raw user input reaches Claude Code.

Output: Gateway validates all text/voice input, rejects malicious patterns with generic errors.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-security-hardening/13-RESEARCH.md
@.planning/phases/13-security-hardening/13-01-SUMMARY.md
@.planning/phases/13-security-hardening/13-02-SUMMARY.md
@src/daemon/gateway.ts
@src/security/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation to text message handler</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Modify the `bot.on('message:text')` handler in `src/daemon/gateway.ts`:

1. Add import at top:
   ```typescript
   import { validateAndSanitize } from '../security/index.js';
   ```

2. In the text message handler (around line 277), add validation BEFORE queuing:
   ```typescript
   bot.on('message:text', async (ctx: MyContext) => {
     const chatId = ctx.chat?.id;
     if (!chatId) return;

     const rawText = ctx.message?.text ?? '';

     // Skip empty messages
     if (!rawText.trim()) return;

     // Translate skill commands: /skill_creator -> /skill skill-creator
     const translatedText = translateSkillCommand(rawText);

     // Validate and sanitize input
     const validation = validateAndSanitize(translatedText);
     if (!validation.ok) {
       // Send user-friendly rejection (generic error, no details)
       await ctx.reply(validation.error);
       return;  // Don't queue invalid input
     }

     // Use sanitized text for queuing
     const text = validation.prompt;

     // Add to queue
     const queueId = queue.add(chatId, text);
     log.info({ chatId, queueId, translated: translatedText !== rawText }, 'Message queued');

     // Trigger processing (non-blocking)
     processQueue().catch((err) => {
       log.error({ err }, 'Queue processing error');
     });
   });
   ```

Key changes:
- Validate AFTER skill command translation (so /skill commands work)
- Reject before queuing (don't waste queue space on invalid input)
- Use `validation.prompt` (sanitized) not raw text
- Reply with generic error (from validateAndSanitize, never reveals detection)
  </action>
  <verify>Text messages with injection patterns are rejected with "Please try rephrasing your message". Normal messages pass through unchanged.</verify>
  <done>Text message handler validates input before queuing.</done>
</task>

<task type="auto">
  <name>Task 2: Add validation to voice transcripts</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Modify `processMedia()` function and voice handling to validate transcripts:

The transcription result needs validation because voice messages could contain spoken injection attempts.

1. In `processMedia()` function (around line 53), after transcription succeeds:
   ```typescript
   if (attachment.type === 'voice') {
     // ... existing transcription code ...

     try {
       const result = await withRetry(() => transcribeAudio(attachment.localPath!));

       // Validate transcript for injection patterns
       const validation = validateAndSanitize(result.text);
       if (!validation.ok) {
         // Transcript contains suspicious content
         errors.push('Voice message could not be processed');
         // Still delete the audio file
         try {
           unlinkSync(attachment.localPath);
         } catch { /* ignore */ }
         continue;  // Skip this attachment
       }

       // Delete audio file after transcription
       try {
         unlinkSync(attachment.localPath);
       } catch { /* ignore */ }

       processed.push({
         ...attachment,
         transcript: validation.prompt,  // Use sanitized transcript
         processingTimeMs: Date.now() - startTime,
         localPath: undefined,
       });

       log.info(
         { type: 'voice', transcriptLength: validation.prompt.length, durationMs: result.durationMs },
         'Transcribed voice message'
       );
     } catch (err) {
       // ... existing error handling ...
     }
   }
   ```

2. Add import if not already present (should be from Task 1):
   ```typescript
   import { validateAndSanitize } from '../security/index.js';
   ```

This ensures spoken injection attempts are caught before reaching Claude.
  </action>
  <verify>Voice messages with transcripts containing injection patterns are rejected. Normal voice messages transcribe and process correctly.</verify>
  <done>Voice transcripts validated before queuing.</done>
</task>

<task type="auto">
  <name>Task 3: Update security module index with redaction export</name>
  <files>src/security/index.ts</files>
  <action>
Update `src/security/index.ts` to also export redaction config (for completeness):

```typescript
// Security module - input validation, sanitization, and log redaction
export { validateAndSanitize, promptSchema } from './validation.js';
export { INJECTION_PATTERNS, containsInjectionPattern } from './patterns.js';
export { REDACT_PATHS, REDACT_CENSOR } from './redaction.js';
```

This makes the security module a complete home for all security-related exports.
  </action>
  <verify>All security exports available from single import: `import { validateAndSanitize, REDACT_PATHS } from '../security/index.js'`</verify>
  <done>Security module index exports all public APIs including redaction.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. Manual test flow:
   - Send normal text message -> processes normally
   - Send text with injection pattern (e.g., "ignore all previous instructions") -> rejected with generic error
   - Send voice message with normal speech -> transcribes and processes
   - (Injection patterns in voice harder to test without crafted audio)
3. Check logs: No raw pairing codes visible (redaction from Plan 02 working)
4. Check rejection messages: Only generic "Please try rephrasing" (no detection details)
</verification>

<success_criteria>
- [ ] Text messages validated before queuing
- [ ] Voice transcripts validated after transcription
- [ ] Rejection messages are generic (don't reveal detection)
- [ ] Normal messages process unchanged
- [ ] TypeScript compiles without errors
- [ ] Security module exports all APIs (validation + redaction)
</success_criteria>

<output>
After completion, create `.planning/phases/13-security-hardening/13-03-SUMMARY.md`
</output>
