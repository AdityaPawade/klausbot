---
phase: 13-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/security/index.ts
  - src/security/validation.ts
  - src/security/patterns.ts
autonomous: true

must_haves:
  truths:
    - "User prompts are validated before passing to Claude"
    - "Injection patterns are detected and rejected"
    - "Validation returns type-safe results with generic error messages"
  artifacts:
    - path: "src/security/index.ts"
      provides: "Security module re-exports"
      exports: ["validateAndSanitize", "containsInjectionPattern"]
    - path: "src/security/validation.ts"
      provides: "Zod-based prompt validation pipeline"
      exports: ["validateAndSanitize", "promptSchema"]
    - path: "src/security/patterns.ts"
      provides: "Injection detection patterns and checker"
      exports: ["INJECTION_PATTERNS", "containsInjectionPattern"]
  key_links:
    - from: "src/security/validation.ts"
      to: "src/security/patterns.ts"
      via: "import containsInjectionPattern"
      pattern: "containsInjectionPattern"
---

<objective>
Create the security module with Zod-based input validation and injection pattern detection.

Purpose: Establish the validation layer that will sanitize all user prompts before they reach Claude Code, preventing prompt injection attacks.

Output: `src/security/` module with validation schemas and injection detection.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-security-hardening/13-RESEARCH.md
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create injection detection patterns</name>
  <files>src/security/patterns.ts</files>
  <action>
Create `src/security/patterns.ts` with:

1. Export `INJECTION_PATTERNS: RegExp[]` array containing patterns from research:
   - Direct instruction override: `/ignore\s+(all\s+)?(previous|prior|above|earlier)\s+(instructions?|rules?|prompts?)/i`
   - Role manipulation: `/you\s+are\s+(now|a)\s+(different|new|an?\s+evil|malicious)/i`
   - System prompt extraction: `/print\s+(your|the)?\s*(system|initial)\s*(prompt|instructions?)/i`
   - Reveal patterns: `/reveal\s+(your|the)?\s*(system|hidden)\s*(prompt|instructions?)/i`
   - Developer/debug mode: `/developer\s+mode|debug\s+mode|admin\s+mode/i`
   - Jailbreak markers: `/\[DAN\]|\[JAILBREAK\]|DUDE\s*:/i`

2. Export `containsInjectionPattern(text: string): boolean` function:
   - Uses multi-signal detection (require 2+ pattern matches) to reduce false positives
   - Returns true only if matchCount >= 2 (as specified in research)

Include JSDoc explaining this is heuristic detection, not foolproof.
  </action>
  <verify>File exists with exported patterns array and checker function. TypeScript compiles without errors.</verify>
  <done>INJECTION_PATTERNS array and containsInjectionPattern function exported and documented.</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation pipeline</name>
  <files>src/security/validation.ts</files>
  <action>
Create `src/security/validation.ts` with:

1. Import Zod (already in project) and patterns from `./patterns.js`

2. Define `MAX_PROMPT_LENGTH = 10000` (reasonable limit from research)

3. Create `promptSchema` using Zod:
   ```typescript
   const promptSchema = z.string()
     .min(1, 'Empty message')
     .max(MAX_PROMPT_LENGTH, 'Message too long')
     .trim()
     .transform((val) => {
       // Normalize unicode whitespace (zero-width chars)
       return val.replace(/[\u200B-\u200D\uFEFF]/g, '');
     })
     .refine(
       (val) => !containsInjectionPattern(val),
       { message: 'Invalid input' }  // Generic - don't reveal detection
     );
   ```

4. Export `validateAndSanitize(input: unknown)` function:
   - Returns discriminated union: `{ ok: true; prompt: string } | { ok: false; error: string }`
   - Uses `promptSchema.safeParse(input)`
   - On failure: returns generic "Please try rephrasing your message" (never reveals detection reason)
   - On success: returns sanitized prompt string

Follow existing Zod patterns from `src/config/schema.ts`.
  </action>
  <verify>`npx tsc --noEmit` passes. Validation function handles edge cases: empty, too long, injection patterns.</verify>
  <done>promptSchema and validateAndSanitize function with type-safe results, generic error messages.</done>
</task>

<task type="auto">
  <name>Task 3: Create security module index</name>
  <files>src/security/index.ts</files>
  <action>
Create `src/security/index.ts` as barrel export:

```typescript
// Security module - input validation and sanitization
export { validateAndSanitize, promptSchema } from './validation.js';
export { INJECTION_PATTERNS, containsInjectionPattern } from './patterns.js';
```

Follow existing module patterns (e.g., src/pairing/index.ts).
  </action>
  <verify>All exports resolve. `import { validateAndSanitize } from '../security/index.js'` works from other modules.</verify>
  <done>Security module index exports all public APIs.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. Manual test: `import { validateAndSanitize } from './src/security/index.js'` resolves
3. Code review: No hardcoded error messages reveal detection logic
</verification>

<success_criteria>
- [ ] src/security/patterns.ts exists with INJECTION_PATTERNS array and containsInjectionPattern function
- [ ] src/security/validation.ts exists with Zod schema and validateAndSanitize function
- [ ] src/security/index.ts exports all public APIs
- [ ] TypeScript compiles without errors
- [ ] Validation returns generic errors (doesn't reveal detection)
</success_criteria>

<output>
After completion, create `.planning/phases/13-security-hardening/13-01-SUMMARY.md`
</output>
