---
phase: 01-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/daemon/gateway.ts
  - src/telegram/commands.ts
  - src/telegram/handlers.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Gateway wires bot -> queue -> spawner -> response"
    - "User message triggers Claude response via Telegram"
    - "Status progression shown during processing"
    - "Errors surfaced to user with category (not stack trace)"
    - "Queue processes messages in order"
  artifacts:
    - path: "src/daemon/gateway.ts"
      provides: "Main processing loop"
      exports: ["startGateway", "stopGateway"]
    - path: "src/index.ts"
      provides: "Entry point and CLI dispatcher"
  key_links:
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/queue.ts"
      via: "queue.take() -> process -> complete/fail"
      pattern: "queue\\.take"
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/spawner.ts"
      via: "queryClaudeCode call"
      pattern: "queryClaudeCode"
    - from: "src/telegram/handlers.ts"
      to: "src/daemon/queue.ts"
      via: "queue.add on message"
      pattern: "queue\\.add"
---

<objective>
Wire all components into working gateway: bot receives message, queues it, spawns Claude, sends response.

Purpose: Complete the core message flow - the fundamental value loop of klausbot.
Output: Working end-to-end flow from Telegram message to Claude response.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gateway processing loop</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Create src/daemon/gateway.ts:

Import all components:
- bot, createRunner, MyContext from ../telegram
- MessageQueue, queryClaudeCode from ./index
- initPairingStore, createPairingMiddleware, handleStartCommand from ../pairing
- config, logger, sendLongMessage from respective modules

Module state:
- let queue: MessageQueue
- let isProcessing: boolean = false
- let shouldStop: boolean = false

Export async function startGateway(): Promise<void>
1. Initialize:
   - ensureDataDir(config.DATA_DIR)
   - queue = new MessageQueue(config.DATA_DIR)
   - initPairingStore(config.DATA_DIR)
   - Log startup stats (pending messages, approved users)

2. Setup bot middleware (ORDER MATTERS):
   - Pairing middleware first (blocks unapproved)
   - Then commands and handlers

3. Update /start command handler to use handleStartCommand from pairing

4. Update message handler to:
   - Add message to queue: queue.add(ctx.chat.id, ctx.message.text)
   - Reply with initial status: "Queued. Processing..."
   - Log: message queued { chatId, queueId }
   - Start processing if not already running

5. Start processing loop (non-blocking):
   - processQueue() runs in background
   - Doesn't block bot polling

6. Create runner and wait for shutdown

Export async function stopGateway(): Promise<void>
- shouldStop = true
- Wait for current processing to finish (with timeout)
- Stop runner

Private async function processQueue(): Promise<void>
- If isProcessing, return (already running)
- isProcessing = true
- While !shouldStop:
  - const msg = queue.take()
  - If no msg: wait 100ms, continue
  - await processMessage(msg)
- isProcessing = false

Private async function processMessage(msg: QueuedMessage): Promise<void>
1. Try to update status message: "Thinking..."
   - Need to track status message ID per chat
   - Use ctx.api.sendMessage for status, store message_id
   - Update with ctx.api.editMessageText

2. Call queryClaudeCode(msg.text) with try/catch

3. On success:
   - queue.complete(msg.id)
   - Delete or update status message
   - Send response via sendLongMessage (handles splitting)
   - Log: message processed { chatId, queueId, duration }

4. On error:
   - Determine error category (timeout, spawn failure, parse error)
   - Format user-friendly message: "Error ({category}): {brief description}"
   - Send error to user
   - queue.fail(msg.id, error.message)
   - Log: message failed { chatId, queueId, error }

Status message progression (CONTEXT.md requirement):
- Use ctx.api.editMessageText to update status
- "Thinking..." -> response (or error)
- For MVP, single status is fine; progression can be enhanced later
  </action>
  <verify>Manual test: send message, verify status appears, Claude responds, status updates/clears</verify>
  <done>Gateway wires all components, processes queue, shows status, handles errors</done>
</task>

<task type="auto">
  <name>Task 2: Update handlers to integrate with queue</name>
  <files>src/telegram/handlers.ts, src/telegram/commands.ts</files>
  <action>
Update src/telegram/handlers.ts:

Remove placeholder echo logic. Instead:
- Accept queue parameter or import from daemon
- On message:text:
  - Log incoming message
  - queue.add(ctx.chat.id, ctx.message.text)
  - Send status message and store message_id for later update
  - Trigger processQueue (if exported) or just let gateway handle it

Export function setupHandlers(queue: MessageQueue, processCallback: () => void):
- Wire queue.add
- Call processCallback after adding (triggers processing)

Update src/telegram/commands.ts:

Update /start to use handleStartCommand from pairing:
- Import handleStartCommand from ../pairing
- bot.command('start', handleStartCommand)

Update /model to be more informative:
- Reply: "Current model: default\nModel switching coming in Phase 2"

Add /status command (useful for debugging):
- Show queue stats: pending, processing, failed
- Show if user is approved
- bot.command('status', handler)

Add /help command:
- List available commands
- "Send any message to chat with Claude"
  </action>
  <verify>Build succeeds; commands respond correctly; messages queue properly</verify>
  <done>Handlers wire to queue, commands updated for pairing integration</done>
</task>

<task type="auto">
  <name>Task 3: Create entry point and CLI dispatcher</name>
  <files>src/index.ts</files>
  <action>
Create src/index.ts as single entry point:

Parse command line args (simple, no library needed for MVP):
- process.argv[2] is subcommand
- Subcommands: daemon, pairing, help

If no subcommand or 'daemon':
- Import and call startGateway()
- This is the main mode

If 'pairing':
- process.argv[3] is action: approve, reject, list, revoke
- process.argv[4] is argument (code or chatId)

- 'pairing approve <code>':
  - Load PairingStore directly (don't start bot)
  - Call store.approvePairing(code)
  - Print success or "Code not found"
  - Exit

- 'pairing reject <code>':
  - Call store.rejectPairing(code)
  - Print result and exit

- 'pairing list':
  - Print pending requests (code, chatId, username, age)
  - Print approved users (chatId, username, age)
  - Exit

- 'pairing revoke <chatId>':
  - Call store.revoke(parseInt(chatId))
  - Print result and exit

If 'help':
- Print usage:
  ```
  klausbot - Telegram gateway for Claude Code

  Usage:
    klausbot [daemon]              Start the gateway daemon
    klausbot pairing approve <code>   Approve pairing request
    klausbot pairing reject <code>    Reject pairing request
    klausbot pairing list             List pending/approved
    klausbot pairing revoke <chatId>  Revoke access
    klausbot help                     Show this help
  ```

Update package.json scripts:
- "start": "node dist/index.js"
- "dev": "tsx src/index.ts"
- Add "bin" field: { "klausbot": "./dist/index.js" }
  </action>
  <verify>npm run build; node dist/index.js help shows usage; node dist/index.js pairing list works</verify>
  <done>Single entry point dispatches to daemon or CLI commands</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Full flow test:
   a. Start daemon: `node dist/index.js`
   b. New user sends message -> blocked, told to /start
   c. User sends /start -> gets pairing code
   d. In another terminal: `node dist/index.js pairing approve <code>`
   e. User sends message -> sees "Thinking...", gets Claude response
   f. Long response splits correctly
   g. Ctrl+C stops daemon gracefully
   h. Restart daemon -> queue state preserved

3. Error handling test:
   - Kill Claude mid-process (if possible) -> user sees error message
   - Send very long message -> handled (queued, processed)

4. Status commands:
   - /status shows queue stats
   - /help lists commands
</verification>

<success_criteria>
- Complete message flow: Telegram -> Queue -> Claude -> Response
- Pairing flow works end-to-end
- CLI commands work (pairing approve/reject/list/revoke)
- Status message shown during processing
- Errors surfaced to user (category + description, no stack traces)
- Queue persists across restart
- Graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
